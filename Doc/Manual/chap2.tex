\chapter{{\tecS}の操作方法}

{\tec}モード，
DEMO1モード，
DEMO2モードでの操作方法は「TeC教科書」\footnote{
\url{https://github.com/tctsigemura/TecTextBook/raw/master/tec.pdf}}
の第４章に詳しく説明されているので，
ここではモードを切り換えるジャンパーの設定方法と，
{\tac}モードでの操作方法だけを説明する．

%-----------------------------------------
\section{ジャンパの設定方法}
ジャンパはプリント基板中央下（\figref{TeC7Photo}参照）に
配置された小さな部品である．
基板側に四本のジャンパピンが正方形に配置されている．
隣り合った二本のジャンパピンをジャンパプラグで導通させることにより，
{\tecS}の動作モードを設定する．
ジャンパの回路図とジャンパプラグの設定位置を\figref{Jumper}に示す．
ジャンパピンの1，2番がFPGA内部の
MODEブロック（\figref{TeC7Blk}参照）に接続されている．
%RN4020をRESETするためには，ジャンパプラグを二個使用する必要がある．
なお，{\tecS}がジャンパの設定を読み取るのは電源投入時だけである．

\begin{description}
  \item[{\tec}モード] ジャンパピンの2番をGNDに接続する．
  \item[{\tac}モード] ジャンパピンの1番をGNDに接続する．
  \item[DEMO1モード] ジャンパピンの1，2番の両方を解放する．
  \item[DEMO2モード] ジャンパピンの1番と2番を接続する．
  \item[RESET（RN4020のリセット）] ジャンパピンの1，2番の両方をGNDに接続する．
\end{description}

\myfigure{tbp}{scale=.8}{Fig/Jumper.pdf}{ジャンパ}{Jumper}

%-----------------------------------------
\section{コンソールのランプやスイッチ}
{\tac}はリセットされると自動的にIPLプログラムの実行を開始する．
プログラム実行中は{\tac}のコンソールが操作不能になる．
プログラムを停止しないとコンソールは使用できない．

\figref{Console}にコンソールパネルの略図を示す．
{\tec}モードと{\tac}モードで役割が変化するランプには，
カッコ書きの小さな文字で{\tac}モードでの役割が表示してある．
例えばD7ランプは，
{\tac}モードではフラグの割り込み許可ビット\texttt{E}を表示することがあるので，
``\texttt{(E)}''の表示がしてある．

\myfigure{tbp}{scale=.8}{Fig/Console.pdf}{TeC7dのコンソールパネル}{Console}

\subsection{アドレスランプ・データランプ}
{\tac}のアドレスやデータは16ビットなので，
アドレスランプとデータランプを合わせた16個のLEDで表示する．
アドレスとデータを同時に表示することはできない．

\subsection{ロータリースイッチ}
\label{rotarySW}
左右矢印の押しボタンでアドレス・データランプに表示するものを切り換える．
{\tac}はCPUレジスタを14本持っているので，
G0，G1，G2，SP，PC，MMの六つのランプで選択中のものを表現できない．
そこで，C，S，Zランプと組合せて選択中のものを表す．
Cランプが点灯中は，六つのランプの上側に三行のカッコ書きで表示してあるものから，
一番下の行を読むと何を選択しているか分かる．
同様にSランプが点灯中は中央の行を読めば良い．
同様にZランプが点灯中は一番上の行を読めば良い．

CPUレジスタの他に，
PC，FLAG，MD（Memory Data），MA（Memory Address register）が選択できる．
MAは，表示や操作の対象となるメモリのアドレスを記憶している
コンソールのレジスタである．
{\tec}と異なりフラグの状態もデータランプに表示される．
プリント基板上でデータランプ上側に印刷されたカッコ書きの表示は，
フラグの名前を表している．

\subsection{データスイッチ}
D7からD0のトグルスイッチは，
8ビットのデータやアドレスを入力するために使用する．
{\tac}のデータやアドレスは16ビットなので二回に分けて入力する．

\subsection{プログラム実行に使用するランプとスイッチ}
RUNランプはCPUがプログラム実行中に点灯する．
BREAK，STEPスイッチとRUN，STOPボタンはプログラムの実行開始・停止などを
指示するために使用する．

\subsection{データ書き換えに使用するスイッチ}
WRITEボタンを押すと，
ロータリースイッチで選択しているものにデータが書き込まれる．
SETA，INCA，DECAはMAの値を操作するために使用する．

%-----------------------------------------
\section{操作手順}

以下の解説は，
特に明示しない限り{\tac}モードでの操作方法の説明である．

\subsection{リセット}
電源投入時に{\tec}と{\tac}の両方がリセットされる．
その後は，
\figref{TeC7Photo}左下のRESETボタンを押してリセットすることができるが，
{\tecS}のモードによってリセットの条件が異なる．

\begin{description}
\item[{\tac}モード]
  RESETボタンを押すと{\tac}だけがリセットされる．
\item[他のモード]
  RESETボタンを押すと通常は{\tec}だけがリセットされる．
  しかし，SETAボタンを押した状態で同時にRESETボタンを押すと
  {\tec}と{\tac}の両方がリセットされる．
\end{description}

\subsection{CPUレジスタやPSWの表示と書き換え}
次の手順でCPUレジスタやPSWの表示と書き換えを行う．

\begin{enumerate}
\item ロータリースイッチを操作して目的のレジスタ等を選択する．
  この時点で，レジスタ等の内容がアドレス・データランプに表示される．
\item データスイッチにデータの上位8ビットをセットする．
\item WRITEボタンを押す．
\item データスイッチにデータの下位8ビットをセットする．
\item WRITEボタンを押す．
\end{enumerate}

\subsection{メモリの表示と書き換え}
メモリは8ビット（1バイト）毎にアドレス付けがされているが，
コンソールからは16ビット（2バイト=1ワード）単位で操作する．
コンソールでは，常に，偶数アドレスを用いる．

\subsubsection{アドレスの設定}
メモリのデータを読み書きするためにはアドレスを指定する必要がある．
まず，MAにアドレスを設定する．
メモリは2バイト単位で操作するので必ず偶数アドレスを用いる．
ユーザが奇数アドレスを入力できないようにしてある．
そのため，目的アドレスの上位8ビットのLSBが1の場合，
一度目のSETAボタンの操作時点ではLSBが0と表示されるが正常である．

MAにアドレスを設定する手順は次の通りである．

\begin{enumerate}
\item ロータリースイッチをMAの位置に合わせる．\\
（アドレスをランプに表示しながら設定しなくてもよい場合は，
MAに合わせなくても良い）
\item データスイッチにアドレスの上位8ビットをセットする．
\item SETAボタンを押す．（WRITEボタンではない）
\item データスイッチにアドレスの下位8ビットをセットする．
\item SETAボタンを押す．
\end{enumerate}

\subsubsection{アドレスの変更}
INCA，DECAボタンを押すとMAのアドレスを増やしたり減らしたりできる．
アドレスが偶数になるよう増減は2刻みになる．

\subsubsection{データの書き込み}
MAに目的のアドレスを設定した後，
以下の操作をすることでメモリにデータを書き込む．
なお，データを書き込んでもMAは自動的に増加しないので注意が必要である．

\begin{enumerate}
\item ロータリースイッチをMAまたはMDの位置に合わせる．
\item データスイッチにデータの上位8ビットをセットする．
\item WRITEボタンを押す．
\item データスイッチにデータの下位8ビットをセットする．
\item WRITEボタンを押す．
\end{enumerate}

\subsection{プログラムの停止・実行・デバッグ}
OSカーネルの内部まで，
ステップ実行などを用いてデバッグすることができる．

\subsubsection{プログラムの停止}
STOPボタンを押すとプログラムが停止する．
OSが動作中でもCPUとタイマー（\ref{timer}参照）が停止し，
コンソールからCPUレジスタやPSW，
メモリの値を参照したり変更したりすることができる．

\subsubsection{特定番地からの実行}
PCの値を変更すれば任意アドレスのプログラムを実行できる．

\begin{enumerate}
\item プログラムの実行開始番地をPCにセットする．
\item BREAK，STEPスイッチが下に倒れていることを確認する．
\item RUNボタンを押す．
  プログラム実行中はRUNランプが点灯している．
\end{enumerate}

\subsubsection{ステップ実行・ブレークポイントを用いたデバッグ}
STEPスイッチを上に倒すと，
機械語命令を一つ実行し終わる毎にCPUが停止するステップ実行モードになる．
ステップ実行モードでは，
RUNボタンを押す度にプログラムを一命令ずつ実行する．

BREAKスイッチを上に，STEPスイッチは下に倒すと，
ブレークポイント実行モードになる．
ブレークポイント実行モードでは，
CPUがメモリのMA番地をアクセスするとCPUが停止する．
MA番地はMMUが出力する物理アドレスではなく，
CPUが出力する論理アドレスによるものである．
命令フェッチとデータの読み書きのどちらでもCPUが停止する点が{\tec}と異なる．

\begin{itembox}[l]{注意}
  BREAK，STEPスイッチが上に倒れていると，
  リセットしてもすぐにCPUが停止してしまうのでOSが起動しない．
  通常は，BREAK，STEPスイッチを必ず下に倒しておくこと．
\end{itembox}

\subsubsection{OSデバッグの例}
以下では，openシステムコールにバグが疑われる時に，
TacOSの内部で\texttt{open()}関数が呼び出された時にCPUを停止する例を示す．

\begin{enumerate}
\item TacOSの配布物を展開し\|kernel.bin|を作成する．
\item 同時に作成された\|kernel.map|ファイルから\|_open|のアドレスを確認する．
\item TacOSを起動する．
\item STOPボタンを押してCPUを一旦停止する．
\item コンソールを操作しMAに\|_open|のアドレスを設定する．
\item BREAKスイッチを上に倒してからRUNボタンを押す．
\item \|open()|が呼ばれた時点でCPUが停止する．
\item コンソールを操作しバグの原因を調査する．
\end{enumerate}
